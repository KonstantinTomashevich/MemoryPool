name: Build

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

jobs:
  build:
    strategy:
      matrix:
        build_type: [ Release, Debug ]
        os: [ windows-latest, ubuntu-latest, macos-latest ]
        toolchain: [ GCC, Clang, MSVC ]
        exclude:
          - os: ubuntu-latest
            toolchain: MSVC
          # TODO: Temporary, because of strange link error.
          - os: macos-latest
            toolchain: GCC
          - os: macos-latest
            toolchain: MSVC
          - os: windows-latest
            toolchain: GCC

    defaults:
      run:
        shell: pwsh

    env:
      BUILD_DIRECTORY: ${{github.workspace}}/Build
      # TODO: Somehow pass runtime output directory directly from CMake to avoid duplication?
      RUNTIME_DIRECTORY: ${{github.workspace}}/Build/Bin
      BUILD_TYPE: ${{matrix.build_type}}

    runs-on: ${{matrix.os}}
    steps:
      # "Setup * toolchain" tasks pass CC and CXX variables values to environment.
      - name: Setup GCC toolchain
        if: matrix.toolchain == 'GCC'
        run: echo 'CC=gcc-10' >> $Env:GITHUB_ENV && echo 'CXX=g++-10' >> $Env:GITHUB_ENV

      - name: Setup Clang toolchain on Unix
        if: matrix.toolchain == 'Clang' && matrix.os != 'windows-latest'
        run: echo 'CC=clang' >> $Env:GITHUB_ENV && echo 'CXX=clang++' >> $Env:GITHUB_ENV

      # Clang on Windows should be specified using -T instead of CC/CXX.
      - name: Setup Clang toolchain on Windows
        if: matrix.toolchain == 'Clang' && matrix.os == 'windows-latest'
        run: echo 'OVERRIDE_TOOLCHAIN=-T clangcl' >> $Env:GITHUB_ENV

      - name: Setup MSVC toolchain
        if: matrix.toolchain == 'MSVC'
        run: echo 'CC=cl' >> $Env:GITHUB_ENV && echo 'CXX=cl' >> $Env:GITHUB_ENV

      # On windows and ubuntu images Boost 1.72 is preinstalled, but it's path must be passed
      # to BOOST_ROOT environment variable from BOOST_ROOT_1_72_0 environment variable.
      - name: Setup Boost environment
        if: (matrix.os == 'windows-latest' && matrix.toolchain != 'Clang') || matrix.os == 'ubuntu-latest'
        run: echo "BOOST_ROOT=$Env:BOOST_ROOT_1_72_0" >> $Env:GITHUB_ENV

      # There is no Clang binaries in default Windows Boost installation and their no such
      # binaries in Chocolatey repositories. Therefore Boost for Clang must be installed manually.
      - name: Build Boost for Windows Clang
        if: matrix.os == 'windows-latest' && matrix.toolchain == 'Clang'
        run: |
          $BOOST_DIST = 'https://dl.bintray.com/boostorg/release/1.72.0/source/boost_1_72_0.zip'
          Invoke-WebRequest $BOOST_DIST -OutFile boost_1_72_0.zip
          Expand-Archive -Path boost_1_72_0.zip -DestinationPath $PWD

          cmd /c 'cd "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Auxiliary\Build" && vcvarsall.bat amd64 && cd "${{github.workspace}}" && cd boost_1_72_0 && bootstrap.bat && b2 install --with-test --with-headers --prefix=boost-build toolset=clang-win address-model=64'
          echo "BOOST_ROOT=$PWD/boost-build" >> $Env:GITHUB_ENV

      # There is no Boost on macos image, therefore it must be installed manually.
      - name: Setup Boost using Homebrew
        if: matrix.os == 'macos-latest'
        run: brew install boost

      # Pass windows-specific executable suffix to environment.
      - name: Setup Windows-specific environment
        if: matrix.os == 'windows-latest'
        run: echo "EXECUTABLE_SUFFIX=.exe" >> $Env:GITHUB_ENV

      - name: Checkout
        uses: actions/checkout@v2
        with:
          submodules: true

      - name: Create build directory
        run: cmake -E make_directory ${{env.BUILD_DIRECTORY}}

      - name: Configure CMake
        working-directory: ${{env.BUILD_DIRECTORY}}
        run: cmake $Env:GITHUB_WORKSPACE -DCMAKE_BUILD_TYPE=${{env.BUILD_TYPE}} ${{env.OVERRIDE_TOOLCHAIN}}

      - name: Build
        working-directory: ${{env.BUILD_DIRECTORY}}
        run: cmake --build .

      - name: Test
        working-directory: ${{env.RUNTIME_DIRECTORY}}
        run: ./MemoryTest${{env.EXECUTABLE_SUFFIX}}

      # For now, benchmarks are executed only to check that they do not crash.
      - name: Run benchmarks
        working-directory: ${{env.RUNTIME_DIRECTORY}}
        run: ./MemoryPoolBenchmark${{env.EXECUTABLE_SUFFIX}}
